博安通：
总体感觉很正式，全方面各层次的了解各个我所掌握的东西
先自我介绍。

然后从：教育经历上来展开
主修课程有哪些？
有哪些编程的主修课程？
从数据结构和算法两方面来考查，我的知识点。
如：堆栈，队列和链表，二叉树的遍历
最后问我的课题是什么？
如何学习这些编程相关知识点
遇到过哪些困难，以及找bug的一套方法？
这个没回答好，有一点可以做的更好的是，缩小范围，调试查看内存中的指针和值，是否和预期的一样，有时候会出现一些比较低级的错误，在于编程的时候没有，定义变量没有赋初值会导致，程序跑飞。数组内存定义过大导致内存溢出。
算法的时间复杂度和空间复杂度如何取舍？

数据结构：栈、堆、队列、二叉树

关于项目方面最后问的：
stm32工程如何从无到有的建立
四部分：启动文件、库文件、驱动文件、用户文件
stm32的启动过程
分配占空间
分配堆内存
设置数据段
设置代码段
然后跳到main函数

我用python写的代码，一个问题都没问我

linux内核和驱动的了解
说了半天还往驱动和应用层这两方面走，说的模糊也不好

职业发展规划是？

我的公司是否符合你的职业发展规划？

期待的新薪水？

为什么没有在原公司继续实习
实习后找完工作，会有重新找工作么？没回答好
应该是希望能够转正，哪怕是自己不愿去。
我回答的比较中立。

------------------------------------------------------


栈机制
获取内存方式：自动分配和回收-----【自动管理】
由于不清理内存中的数据，分配时任然保留原来的值 ---- 【脏内存】
不要返回栈变量的地址，由于反复使用，地址指向的内存中的数据会被改写，避免数据的混杂 ― 【临时的】
栈有大小：无穷尽分配会导致栈溢出，局部函数递归调用分配内存，而没有写停止条件，导致栈溢出（内存泄漏）。 C 【栈溢出】
具体体现：定义局部变量时，自动分配和回收，不清理内存中数据。
内存连续的，先进后出。

堆的机制
按需分配：手动申请（int p_i = malloc（10sizeof（int）））和释放（free（p_i）; p_i = NULL(防止野指针的出现)）
野指针：指向不确定的指针，
危害：指向不可访问地址（发生段错位）；指向可访问，但没有使用的地址，给程序带来隐患；指向可访问，但正在使用的地址，影响程序的运行。
大块内存：比栈内存大的多
脏内存：使用完不会清理指针指向内存中的数据
堆是不连续的

队列：

数据结构基本类型：集合、线性结构、树形结构和图状结构；
线性结构：元素和元素之间存在一一对应的关系
    如：数组、栈、队列、链表
数组：可快速访问任何位置的元素
栈：先进后出，只能在栈顶插入和删除
队列：先进先出，队尾插入，队头删除
链表：逻辑上是连续的，由指针指向各个区域，空间上一般不连续
链表不像数组一样可快速访问任意原素的位置，但可以任意插入、删除任意一个节点，比较灵活。

数形结构：元素之间存在一对多的关系

图形结构：每个节点前驱节点数和后续节点数可以任意

二叉树定义：每个节点最多有两个子树的结构
性质：
二叉树第i层上的结点数目最多为：2的i-1次方（i>=1）
深度为k的二叉树至多有2的k次方-1个节点
包含n个结点的二叉树的高度至少为？
?

1.栈和队列区别
- 栈(Stack)：只允许在一端进行插入或删除操作的线性表。
    - 栈顶(Top): 线性表允许进行插入和删除的那一端
    - 栈底(Bottom): 固定的，不允许进行插入和删除操作的另一端。
    - 空栈：不含任何元素的空表。
    - 栈的一个明显的操作特性：后进先出(Last In First Out, LIFO),故又称为后进先出的线性表。

- 队列(Queue): 队列简称队，只允许在表的一端进行插入，而在表的另一端进行删除 向队列中插入元素称为入队或进队；删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的。其操作的特性是先进先出(First In First Out, FIFO)，故又称为先进先出的线性表。
    - 队头(Front):允许删除的一端，又称为队首。
    - 队尾(Rear): 允许插入的一端。
    - 空队列：不含任何元素的空表
2.数组和链表区别？
- 结构上：数组连续内存空间，链表指针链接的空间
- 使用：数据声明需要长度，随机访问效率高，数据个数可大于数组长度，插入和删除需要一定其他元素；链表线性结构只能从前往后访问，效率低，可方便的插入和删除节点

#### 3获取内存的三种情况：栈（stack）、堆（heap）和数据区（.data）

### 栈机制

- 获取内存方式：自动分配和回收-----【自动管理】
- 由于不清理内存中的数据，分配时任然保留原来的值 ---- 【脏内存】
- 不要返回栈变量的地址，由于**反复使用**，地址指向的内存中的数据会被改写，避免数据的混杂 --- 【临时的】
- 栈有大小：午穷尽分配会导致栈溢出，局部函数递归调用分配内存，而没有写停止条件，导致栈溢出（内存泄漏）。 -- 【栈溢出】
- 具体体现：定义局部变量时，自动分配和回收，不清理内存中数据。
- 内存连续的，先进后出。

### 堆的机制

- 按需分配：手动申请（int *p_i = malloc（10*sizeof（int）））和释放（free（p_i）; p_i = NULL(防止野指针的出现)）
    - 野指针：指向不确定的指针，
    - 危害：指向不可访问地址（发生段错位）；指向可访问，但没有使用的地址，给程序带来隐患；指向可访问，但正在使用的地址，影响程序的运行。
- 大块内存：比栈内存大的多
- 脏内存：使用完不会清理指针指向内存中的数据

